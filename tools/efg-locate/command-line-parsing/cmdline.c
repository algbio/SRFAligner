/*
  File autogenerated by gengetopt version 2.23
  generated with the following command:
  gengetopt --input=./command-line-parsing/config.ggo --output-dir=./command-line-parsing/ --unnamed-opts 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "Program to perform exact and approximate pattern matching on indexable Elastic\nFounder Graphs.";

const char *gengetopt_args_info_usage = "Usage: efg-locate graph.gfa patterns.fasta {paths.gaf,seeds.gaf}";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "The program takes in input an indexable Elastic Founder Graph (xGFA) and a set\nof patterns in FASTA format. In normal mode, the program searches for an exact\noccurrence of the patterns in the graph, the output is in GFA path format, and\nthe exit value is 0 if all patterns occur and 1 otherwise. In approximate mode\n(--approximate), the program greedily searches for semi-repeat-free seeds\nbetween the patterns and the graph, and the output is in GAF format.";

const char *gengetopt_args_info_full_help[] = {
  "  -h, --help                    Print help and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "      --ignore-chars=STRING     Ignore these characters for the indexability\n                                  property/pattern matching, breaking up each\n                                  pattern into maximal strings of non-ignore\n                                  characters",
  "      --approximate             Approximate pattern matching by greedily\n                                  matching the pattern in the graph and\n                                  starting over when the matching fails; output\n                                  only the recognized matches spanning at least\n                                  a full node  (default=off)",
  "      --approximate-edge-match-min-count=COUNT\n                                Consider any approximate occurrence valid if\n                                  the pattern substring occurs at most COUNT\n                                  times in the edges  (default=`0')",
  "      --approximate-edge-match-longest=COUNT\n                                Consider the COUNT longest substrings of the\n                                  pattern appearing in the edges valid\n                                  (default=`0')",
  "      --approximate-edge-match-longest-max-count=COUNT\n                                Consider the COUNT longest substrings valid\n                                  only if they appear less than N times in the\n                                  edges  (default=`1000')",
  "      --approximate-min-coverage=PERC\n                                Consider approximate occurrences as valid if\n                                  they cover at least PERC % of the pattern\n                                  (default=`0')",
  "      --approximate-stats       Output statistics for each read in stdout\n                                  (default=off)",
  "      --reverse-complement      Match also the reverse complement of the\n                                  patterns and output the results as a reverse\n                                  graph path  (default=off)",
  "      --rename-reverse-complement\n                                When matching the reverse complement of\n                                  patterns, consider them as a distinct\n                                  patterns by prepending 'rev_' to its name\n                                  (default=off)",
  "      --split-output-matches    In approximate mode (--approximate), split long\n                                  matches into node matches  (default=off)",
  "      --split-output-matches-graphaligner\n                                Same as --split-output-matches, but filter out\n                                  node matches of length 1 (for use with\n                                  GraphAligner --extend)  (default=off)",
  "      --split-keep-edge-matches In approximate mode and using option\n                                  --split-output-matches or\n                                  --split-output-matches-graphaligner, do not\n                                  split edge matches  (default=off)",
  "  -t, --threads=THREADNUM       Number of compute threads  (default=`-1')",
  "      --overwrite               Overwrite the output file, if it exists\n                                  (default=off)",
    0
};

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_full_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_full_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_full_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_full_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_full_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_full_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_full_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_full_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_full_help[9];
  gengetopt_args_info_help[9] = gengetopt_args_info_full_help[10];
  gengetopt_args_info_help[10] = gengetopt_args_info_full_help[11];
  gengetopt_args_info_help[11] = gengetopt_args_info_full_help[12];
  gengetopt_args_info_help[12] = gengetopt_args_info_full_help[13];
  gengetopt_args_info_help[13] = gengetopt_args_info_full_help[14];
  gengetopt_args_info_help[14] = gengetopt_args_info_full_help[15];
  gengetopt_args_info_help[15] = gengetopt_args_info_full_help[16];
  gengetopt_args_info_help[16] = 0; 
  
}

const char *gengetopt_args_info_help[17];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_LONG
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->ignore_chars_given = 0 ;
  args_info->approximate_given = 0 ;
  args_info->approximate_edge_match_min_count_given = 0 ;
  args_info->approximate_edge_match_longest_given = 0 ;
  args_info->approximate_edge_match_longest_max_count_given = 0 ;
  args_info->approximate_min_coverage_given = 0 ;
  args_info->approximate_stats_given = 0 ;
  args_info->reverse_complement_given = 0 ;
  args_info->rename_reverse_complement_given = 0 ;
  args_info->split_output_matches_given = 0 ;
  args_info->split_output_matches_graphaligner_given = 0 ;
  args_info->split_keep_edge_matches_given = 0 ;
  args_info->threads_given = 0 ;
  args_info->overwrite_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->ignore_chars_arg = NULL;
  args_info->ignore_chars_orig = NULL;
  args_info->approximate_flag = 0;
  args_info->approximate_edge_match_min_count_arg = 0;
  args_info->approximate_edge_match_min_count_orig = NULL;
  args_info->approximate_edge_match_longest_arg = 0;
  args_info->approximate_edge_match_longest_orig = NULL;
  args_info->approximate_edge_match_longest_max_count_arg = 1000;
  args_info->approximate_edge_match_longest_max_count_orig = NULL;
  args_info->approximate_min_coverage_arg = 0;
  args_info->approximate_min_coverage_orig = NULL;
  args_info->approximate_stats_flag = 0;
  args_info->reverse_complement_flag = 0;
  args_info->rename_reverse_complement_flag = 0;
  args_info->split_output_matches_flag = 0;
  args_info->split_output_matches_graphaligner_flag = 0;
  args_info->split_keep_edge_matches_flag = 0;
  args_info->threads_arg = -1;
  args_info->threads_orig = NULL;
  args_info->overwrite_flag = 0;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{

  init_help_array(); 
  args_info->help_help = gengetopt_args_info_full_help[0] ;
  args_info->full_help_help = gengetopt_args_info_full_help[1] ;
  args_info->version_help = gengetopt_args_info_full_help[2] ;
  args_info->ignore_chars_help = gengetopt_args_info_full_help[3] ;
  args_info->approximate_help = gengetopt_args_info_full_help[4] ;
  args_info->approximate_edge_match_min_count_help = gengetopt_args_info_full_help[5] ;
  args_info->approximate_edge_match_longest_help = gengetopt_args_info_full_help[6] ;
  args_info->approximate_edge_match_longest_max_count_help = gengetopt_args_info_full_help[7] ;
  args_info->approximate_min_coverage_help = gengetopt_args_info_full_help[8] ;
  args_info->approximate_stats_help = gengetopt_args_info_full_help[9] ;
  args_info->reverse_complement_help = gengetopt_args_info_full_help[10] ;
  args_info->rename_reverse_complement_help = gengetopt_args_info_full_help[11] ;
  args_info->split_output_matches_help = gengetopt_args_info_full_help[12] ;
  args_info->split_output_matches_graphaligner_help = gengetopt_args_info_full_help[13] ;
  args_info->split_keep_edge_matches_help = gengetopt_args_info_full_help[14] ;
  args_info->threads_help = gengetopt_args_info_full_help[15] ;
  args_info->overwrite_help = gengetopt_args_info_full_help[16] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void)
{
	size_t len_purpose = strlen(gengetopt_args_info_purpose);
	size_t len_usage = strlen(gengetopt_args_info_usage);

	if (len_usage > 0) {
		printf("%s\n", gengetopt_args_info_usage);
	}
	if (len_purpose > 0) {
		printf("%s\n", gengetopt_args_info_purpose);
	}

	if (len_usage || len_purpose) {
		printf("\n");
	}

	if (strlen(gengetopt_args_info_description) > 0) {
		printf("%s\n\n", gengetopt_args_info_description);
	}
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->ignore_chars_arg));
  free_string_field (&(args_info->ignore_chars_orig));
  free_string_field (&(args_info->approximate_edge_match_min_count_orig));
  free_string_field (&(args_info->approximate_edge_match_longest_orig));
  free_string_field (&(args_info->approximate_edge_match_longest_max_count_orig));
  free_string_field (&(args_info->approximate_min_coverage_orig));
  free_string_field (&(args_info->threads_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->ignore_chars_given)
    write_into_file(outfile, "ignore-chars", args_info->ignore_chars_orig, 0);
  if (args_info->approximate_given)
    write_into_file(outfile, "approximate", 0, 0 );
  if (args_info->approximate_edge_match_min_count_given)
    write_into_file(outfile, "approximate-edge-match-min-count", args_info->approximate_edge_match_min_count_orig, 0);
  if (args_info->approximate_edge_match_longest_given)
    write_into_file(outfile, "approximate-edge-match-longest", args_info->approximate_edge_match_longest_orig, 0);
  if (args_info->approximate_edge_match_longest_max_count_given)
    write_into_file(outfile, "approximate-edge-match-longest-max-count", args_info->approximate_edge_match_longest_max_count_orig, 0);
  if (args_info->approximate_min_coverage_given)
    write_into_file(outfile, "approximate-min-coverage", args_info->approximate_min_coverage_orig, 0);
  if (args_info->approximate_stats_given)
    write_into_file(outfile, "approximate-stats", 0, 0 );
  if (args_info->reverse_complement_given)
    write_into_file(outfile, "reverse-complement", 0, 0 );
  if (args_info->rename_reverse_complement_given)
    write_into_file(outfile, "rename-reverse-complement", 0, 0 );
  if (args_info->split_output_matches_given)
    write_into_file(outfile, "split-output-matches", 0, 0 );
  if (args_info->split_output_matches_graphaligner_given)
    write_into_file(outfile, "split-output-matches-graphaligner", 0, 0 );
  if (args_info->split_keep_edge_matches_given)
    write_into_file(outfile, "split-keep-edge-matches", 0, 0 );
  if (args_info->threads_given)
    write_into_file(outfile, "threads", args_info->threads_orig, 0);
  if (args_info->overwrite_given)
    write_into_file(outfile, "overwrite", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  FIX_UNUSED (args_info);
  FIX_UNUSED (prog_name);
  return EXIT_SUCCESS;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_LONG:
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_LONG:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  /* TODO: Why is this here? It is not used anywhere. */
  override = params->override;
  FIX_UNUSED(override);

  initialize = params->initialize;
  check_required = params->check_required;

  /* TODO: Why is this here? It is not used anywhere. */
  check_ambiguity = params->check_ambiguity;
  FIX_UNUSED(check_ambiguity);

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "ignore-chars",	1, NULL, 0 },
        { "approximate",	0, NULL, 0 },
        { "approximate-edge-match-min-count",	1, NULL, 0 },
        { "approximate-edge-match-longest",	1, NULL, 0 },
        { "approximate-edge-match-longest-max-count",	1, NULL, 0 },
        { "approximate-min-coverage",	1, NULL, 0 },
        { "approximate-stats",	0, NULL, 0 },
        { "reverse-complement",	0, NULL, 0 },
        { "rename-reverse-complement",	0, NULL, 0 },
        { "split-output-matches",	0, NULL, 0 },
        { "split-output-matches-graphaligner",	0, NULL, 0 },
        { "split-keep-edge-matches",	0, NULL, 0 },
        { "threads",	1, NULL, 't' },
        { "overwrite",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVt:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 't':	/* Number of compute threads.  */
        
        
          if (update_arg( (void *)&(args_info->threads_arg), 
               &(args_info->threads_orig), &(args_info->threads_given),
              &(local_args_info.threads_given), optarg, 0, "-1", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "threads", 't',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            cmdline_parser_print_full_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          /* Ignore these characters for the indexability property/pattern matching, breaking up each pattern into maximal strings of non-ignore characters.  */
          if (strcmp (long_options[option_index].name, "ignore-chars") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ignore_chars_arg), 
                 &(args_info->ignore_chars_orig), &(args_info->ignore_chars_given),
                &(local_args_info.ignore_chars_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "ignore-chars", '-',
                additional_error))
              goto failure;
          
          }
          /* Approximate pattern matching by greedily matching the pattern in the graph and starting over when the matching fails; output only the recognized matches spanning at least a full node.  */
          else if (strcmp (long_options[option_index].name, "approximate") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->approximate_flag), 0, &(args_info->approximate_given),
                &(local_args_info.approximate_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "approximate", '-',
                additional_error))
              goto failure;
          
          }
          /* Consider any approximate occurrence valid if the pattern substring occurs at most COUNT times in the edges.  */
          else if (strcmp (long_options[option_index].name, "approximate-edge-match-min-count") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->approximate_edge_match_min_count_arg), 
                 &(args_info->approximate_edge_match_min_count_orig), &(args_info->approximate_edge_match_min_count_given),
                &(local_args_info.approximate_edge_match_min_count_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "approximate-edge-match-min-count", '-',
                additional_error))
              goto failure;
          
          }
          /* Consider the COUNT longest substrings of the pattern appearing in the edges valid.  */
          else if (strcmp (long_options[option_index].name, "approximate-edge-match-longest") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->approximate_edge_match_longest_arg), 
                 &(args_info->approximate_edge_match_longest_orig), &(args_info->approximate_edge_match_longest_given),
                &(local_args_info.approximate_edge_match_longest_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "approximate-edge-match-longest", '-',
                additional_error))
              goto failure;
          
          }
          /* Consider the COUNT longest substrings valid only if they appear less than N times in the edges.  */
          else if (strcmp (long_options[option_index].name, "approximate-edge-match-longest-max-count") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->approximate_edge_match_longest_max_count_arg), 
                 &(args_info->approximate_edge_match_longest_max_count_orig), &(args_info->approximate_edge_match_longest_max_count_given),
                &(local_args_info.approximate_edge_match_longest_max_count_given), optarg, 0, "1000", ARG_INT,
                check_ambiguity, override, 0, 0,
                "approximate-edge-match-longest-max-count", '-',
                additional_error))
              goto failure;
          
          }
          /* Consider approximate occurrences as valid if they cover at least PERC % of the pattern.  */
          else if (strcmp (long_options[option_index].name, "approximate-min-coverage") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->approximate_min_coverage_arg), 
                 &(args_info->approximate_min_coverage_orig), &(args_info->approximate_min_coverage_given),
                &(local_args_info.approximate_min_coverage_given), optarg, 0, "0", ARG_INT,
                check_ambiguity, override, 0, 0,
                "approximate-min-coverage", '-',
                additional_error))
              goto failure;
          
          }
          /* Output statistics for each read in stdout.  */
          else if (strcmp (long_options[option_index].name, "approximate-stats") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->approximate_stats_flag), 0, &(args_info->approximate_stats_given),
                &(local_args_info.approximate_stats_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "approximate-stats", '-',
                additional_error))
              goto failure;
          
          }
          /* Match also the reverse complement of the patterns and output the results as a reverse graph path.  */
          else if (strcmp (long_options[option_index].name, "reverse-complement") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->reverse_complement_flag), 0, &(args_info->reverse_complement_given),
                &(local_args_info.reverse_complement_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "reverse-complement", '-',
                additional_error))
              goto failure;
          
          }
          /* When matching the reverse complement of patterns, consider them as a distinct patterns by prepending 'rev_' to its name.  */
          else if (strcmp (long_options[option_index].name, "rename-reverse-complement") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->rename_reverse_complement_flag), 0, &(args_info->rename_reverse_complement_given),
                &(local_args_info.rename_reverse_complement_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "rename-reverse-complement", '-',
                additional_error))
              goto failure;
          
          }
          /* In approximate mode (--approximate), split long matches into node matches.  */
          else if (strcmp (long_options[option_index].name, "split-output-matches") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->split_output_matches_flag), 0, &(args_info->split_output_matches_given),
                &(local_args_info.split_output_matches_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "split-output-matches", '-',
                additional_error))
              goto failure;
          
          }
          /* Same as --split-output-matches, but filter out node matches of length 1 (for use with GraphAligner --extend).  */
          else if (strcmp (long_options[option_index].name, "split-output-matches-graphaligner") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->split_output_matches_graphaligner_flag), 0, &(args_info->split_output_matches_graphaligner_given),
                &(local_args_info.split_output_matches_graphaligner_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "split-output-matches-graphaligner", '-',
                additional_error))
              goto failure;
          
          }
          /* In approximate mode and using option --split-output-matches or --split-output-matches-graphaligner, do not split edge matches.  */
          else if (strcmp (long_options[option_index].name, "split-keep-edge-matches") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->split_keep_edge_matches_flag), 0, &(args_info->split_keep_edge_matches_given),
                &(local_args_info.split_keep_edge_matches_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "split-keep-edge-matches", '-',
                additional_error))
              goto failure;
          
          }
          /* Overwrite the output file, if it exists.  */
          else if (strcmp (long_options[option_index].name, "overwrite") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->overwrite_flag), 0, &(args_info->overwrite_given),
                &(local_args_info.overwrite_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "overwrite", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



	FIX_UNUSED(check_required);

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
/* vim: set ft=c noet ts=8 sts=8 sw=8 tw=80 nojs spell : */
